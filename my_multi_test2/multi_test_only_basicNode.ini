[General]
network =myuav.UAVNetwork_OnlyBasicNode
image-path="images/device"
description = 30 UAVS only
sim-time-limit = 60s	#仿真的持续时间


#【AODV专用设置】
*.configurator.addStaticRoutes = false#不默认设置路由
#初始化路由设置
**.arp.typename = "GlobalArp"
**.basicHosts[*].forwarding = true
**.basicHosts[*].multicastForwarding = true

#**.hostRouters[*].forwarding = true
#**.hostRouters[*].multicastForwarding = true

#【其他设置】
*.numHosts = 30
#*.numRouters = 5
debug-on-errors = true#在错误时候显示debug信息
*.configurator.config = xmldoc("multi_test.xml")#读取xml文件
#写入xml结果方便查看
*.configurator.dumpAddresses = true		#分配IP地址
*.configurator.dumpTopology = true		#打印网络拓扑结构
*.configurator.dumpLinks = true			#打印网络连接
*.configurator.dumpRoutes = true		#打印节点的路由表
*.configurator.dumpConfig = "multi_test_dump.xml"


#【其他奇怪的设置】
num-rngs = 3
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 1
#**.host*.**.channelNumber = 0

#【3D设置】
*.visualizer.osgVisualizer.typename = "IntegratedOsgVisualizer"
*.visualizer.osgVisualizer.sceneVisualizer.clearColor = "skyblue"
*.visualizer.osgVisualizer.sceneVisualizer.sceneImage = "showcases/desert"
*.visualizer.osgVisualizer.sceneVisualizer.sceneImageSize = 2000m	#5000m
*.visualizer.osgVisualizer.sceneVisualizer.axisLength = 500m		#1000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMinX = 0m			#-2000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMinY = 0m			#-2000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMinZ = 0m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMaxX = 2000m		#3000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMaxY = 2000m		#3000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMaxZ = 1000m		#3000m


#【可视化设置】
##干扰范围和通信范围
#**.radio.displayCommunicationRange = true
#*.visualizer.*.mediumVisualizer.displayCommunicationRanges = true	#通信范围可视化
#**.radio.displayInterferenceRange = true
#*.visualizer.*.mediumVisualizer.displayInterferenceRanges = true	#干扰范围可视化
#*.visualizer.*.mediumVisualizer.displaySignals = true	#传输显示为从主机发出的彩色环
#物理层
#*.visualizer.*.physicalLinkVisualizer.displayLinks = true
#数据链路层
#*.visualizer.*.dataLinkVisualizer.displayLinks = true
#*.visualizer.*.dataLinkVisualizer.packetFilter = "ping*"	#AODV*
#*.visualizer.*.dataLinkVisualizer.nodeFilter = "basicHosts*"		#hostRouter*
#*.visualizer.*.dataLinkVisualizer.lineWidth = 5
#*.visualizer.*.dataLinkVisualizer.lineColor = "green"
#*.visualizer.*.dataLinkVisualizer.lineShift = 0
#网络层
#*.visualizer.*.networkRouteVisualizer.displayRoutes = true
#*.visualizer.*.networkRouteVisualizer.packetFilter = "ping*"
#*.visualizer.*.networkRouteVisualizer.nodeFilter = "basicHosts*"		#hostRouter*
#*.visualizer.*.networkRouteVisualizer.lineWidth = 10
#*.visualizer.*.networkRouteVisualizer.lineColor = "blue"
#*.visualizer.*.networkRouteVisualizer.lineShift = 0
##可视化接口地址
#*.visualizer.*.interfaceTableVisualizer.displayInterfaceTables = true
##注意忽略Switch和AP接入点，因为他们没有IP地址
#*.visualizer.*.interfaceTableVisualizer.nodeFilter = "not (*switch* or *Switch* or *AP*)"
#显示移动速度和轨迹
#*.visualizer.*.mobilityVisualizer.displayVelocities = true
*.visualizer.*.mobilityVisualizer.displayMovementTrails = true
*.visualizer.*.mobilityVisualizer.animationSpeed = 1


#【无线电，mac层等设置】
#*.hostRouters[*].wlan[0].typename = "WirelessInterface"
*.basicHosts[*].wlan[0].typename = "WirelessInterface"
#打开mac层的ack回复机制
#*.hostRouters[*].wlan[0].mac.typename = "CsmaCaMac"
#*.hostRouters[*].wlan[0].mac.ackTimeout = 300us	#300us
*.basicHosts[*].wlan[0].mac.typename = "CsmaCaMac"
*.basicHosts[*].wlan[0].mac.ackTimeout = 300us	#300us

#最大队列长度
**.wlan[*].queue.typename = "DropTailQueue" #in routers
#簇头最大队列长度加大
#*.hostRouters[*].wlan[0].mac.maxQueueSize = 20000
*.basicHosts[*].wlan[0].mac.maxQueueSize = 10000				#10000

*.radioMedium.typename = "ApskScalarRadioMedium"		#ApskScalarRadioMedium
*.radioMedium.backgroundNoise.power = -90dBm			#背景的噪声模型 -90
*.radioMedium.mediumLimitCache.carrierFrequency = 2GHz	#载波频率

#TODO 需要根据host和Router的性质进行更改
#*.hostRouters[*].wlan[0].radio.typename = "ApskScalarRadio"	#ApskScalarRadio
#*.hostRouters[*].wlan[0].radio.carrierFrequency = 2GHz			#载波频率
*.basicHosts[*].wlan[0].radio.typename = "ApskScalarRadio"	#ApskScalarRadio
*.basicHosts[*].wlan[0].radio.carrierFrequency = 2GHz			#载波频率
**.ignorePartialInterference = true
#ATTENTION! 不同的带宽会导致loss rate急速增长 不要轻易更改!!
#*.hostRouters[*].wlan[0].radio.bandwidth = 10MHz		
#*.hostRouters[*].wlan[0].radio.transmitter.preambleDuration = 10us	#10us
#*.hostRouters[*].wlan[0].radio.transmitter.headerLength = 8b
*.basicHosts[*].wlan[0].radio.bandwidth = 10MHz		
*.basicHosts[*].wlan[0].radio.transmitter.preambleDuration = 10us	#10us
*.basicHosts[*].wlan[0].radio.transmitter.headerLength = 8b
#信号强度过低就不会被接收到
#*.hostRouters[*].wlan[0].radio.receiver.sensitivity = -85dBm		
#*.hostRouters[*].wlan[0].radio.receiver.energyDetection = -85dBm	
#*.hostRouters[*].wlan[0].radio.receiver.snirThreshold = 4dB
*.basicHosts[*].wlan[0].radio.receiver.sensitivity = -85dBm		
*.basicHosts[*].wlan[0].radio.receiver.energyDetection = -85dBm	
*.basicHosts[*].wlan[0].radio.receiver.snirThreshold = 4dB

#簇头的传输速率更大
#**.hostRouters[*].**.bitrate = 1Mbps#无线电数据传输速率
**.basicHosts[*].**.bitrate = 1Mbps#无线电数据传输速率
#**.hostRouters[*].wlan[*].radio.transmitter.power = 20mW	 	 #簇头节点的通信范围设置   8
**.basicHosts[*].wlan[*].radio.transmitter.power = 15mW	 	 #其他普通节点的范围设置 	 2

##或许是因为ApskScalarRadio没有这个干扰范围的问题 暂时不管
#*.host*.wlan[*].radio.**.interferenceRange = 500m


#【路径损耗模型 障碍物损耗】
#路径损耗
*.radioMedium.pathLoss.typename = ${pathlosstype="FreeSpacePathLoss","TwoRayInterference","RicianFading","LogNormalShadowing"}
#障碍物损耗
*.physicalEnvironment.coordinateSystemModule = "coordinateSystem"
*.*.mobility.coordinateSystemModule = "coordinateSystem" # reference TODO new add
#*.physicalEnvironment.spaceMinX = 100m
#*.physicalEnvironment.spaceMinY = 100m
#*.physicalEnvironment.spaceMinZ = 100m
#*.physicalEnvironment.spaceMaxX = 500m
#*.physicalEnvironment.spaceMaxY = 600m
#*.physicalEnvironment.spaceMaxZ = 700m
*.physicalEnvironment.config = xmldoc("obstacles.xml")
*.radioMedium.obstacleLoss.typename = "DielectricObstacleLoss"

#【ping设置】
#按簇进行更改 簇头和所有节点通信 簇内其他节点和本簇头通信
#**.hostRouters[*].app[*].typename = "PingApp"
**.basicHosts[*].app[*].typename = "PingApp"
#*.hostRouters[*].numApps = 1
*.basicHosts[*].numApps = 1

#关于ping的count的说法
#要指定发送到[单个目标地址]的ping请求的数量，请使用'count'参数。在将指定数量的ping请求发送到目标地址后，应用程序进入睡眠状态，时间为“sleepDuration”。
#一旦睡眠计时器过期，应用程序将切换到下一个目标并再次开始ping。一旦测试了所有目标地址或模拟时间达到“stopTime”，应用程序停止ping。
**.basicHosts[*].app[*].count = 1
**.basicHosts[*].app[*].continuous = true	#持续ping是不用改的。
#**.hostRouters[*].app[*].count = 1
#**.hostRouters[*].app[*].continuous = true	#持续ping是不用改的。

##簇头节点 和其他簇头节点以及本簇内节点通信;其他节点和本簇内所有节点通信
#**.hostRouters[0].app[*].destAddr="hostRouters[1] hostRouters[2] hostRouters[3] hostRouters[4]"
#**.hostRouters[1].app[*].destAddr="hostRouters[0] hostRouters[2] hostRouters[3] hostRouters[4]"
#**.hostRouters[2].app[*].destAddr="hostRouters[0] hostRouters[1] hostRouters[3] hostRouters[4]"
#**.hostRouters[3].app[*].destAddr="hostRouters[0] hostRouters[1] hostRouters[2] hostRouters[4]"
#**.hostRouters[4].app[*].destAddr="hostRouters[0] hostRouters[1] hostRouters[2] hostRouters[3]"
#
##另一种写法 似乎有错误
##**.hostRouters[*].app[*].destAddr="hostRouters[*]"
##10s,15s
#**.hostRouters[*].app[*].startTime = uniform(5s,6s) 	# 簇头节点的第一次通信比较慢
##**.hostRouters[*].app[*].sendInterval = 3s				# 簇头的通信发送间隔比较大
#**.hostRouters[*].app[*].printPing = true					# 这些printPing仅仅是在console里进行输出的 与visualizer无关!
#其他簇内节点0.1s 0.3s
#TODO 关于ping的问题。
#我希望，对于一个普通host来说 它只跟它通信范围内的节点进行ping(或者跟所有的都ping 但是只跟它通信范围内的能ping成功 )
**.basicHosts[*].app[*].destAddr = "*"	#hostA[1] hostA[2] hostRouters[0]
**.basicHosts[*].app[*].startTime = uniform(3s,4s) 	# 簇内节点通信较快
#**.basicHosts[*].app[*].hopLimit = 1			#TODO 考虑到这个版本仅有基础的节点，那么是否也应该动态设置的??
#**.hostA[*].app[*].sendInterval = 0.5s			# 簇头的通信发送间隔比较大
**.basicHosts[*].app[*].printPing = true


#【移动性各种设置】
#TODO 簇头移动性不变 簇内各节点用mass+attached
#**.hostRouters[*].mobility.typename = "MassMobility"#先设置Z轴
#**.hostRouters[*].mobility.initFromDisplayString = false	#全部移动设备"**"的mobility
**.basicHosts[*].mobility.typename = "MassMobility"#先设置Z轴
**.basicHosts[*].mobility.initFromDisplayString = false	#全部移动设备"**"的mobility

##TODO 不同的修改成不同model
#**.hostRouters[*].osgModel = "3d/drone.ive.80.scale.0,0,90.rot"	# Router较大
**.basicHosts[*].osgModel = "3d/drone.ive.20.scale.0,0,90.rot"			# 其他簇内节点较小

#**.hostRouters[*].mobility.initialMovementHeading = uniform(0deg, 360deg)#初始化的UAV头朝向
#**.hostRouters[*].mobility.initialMovementElevation = uniform(-90deg, 90deg)#初始的UAV头俯仰角
#**.hostRouters[*].mobility.rotationAxisAngle = uniform(-10deg,10deg)
#**.hostRouters[*].mobility.faceForward = false
**.basicHosts[*].mobility.initialMovementHeading = uniform(0deg, 360deg)#初始化的UAV头朝向
**.basicHosts[*].mobility.initialMovementElevation = uniform(-90deg, 90deg)#初始的UAV头俯仰角
**.basicHosts[*].mobility.rotationAxisAngle = uniform(-10deg,10deg)
**.basicHosts[*].mobility.faceForward = false

#簇头节点的移动性更大,变化频率更快,绕轴的变化范围大;而其他的节点移动性小,变化频率慢,绕轴的变化范围小
#**.hostRouters[*].mobility.speed = truncnormal(50mps,8mps)	#速度每changeInterval进行一次变化
#**.hostRouters[*].mobility.changeInterval = truncnormal(2s, 1s) # between turns 
#**.hostRouters[*].mobility.angleDelta = normal(-20deg, 20deg)#绕轴的旋转速度矢量

**.basicHosts[*].mobility.speed = truncnormal(20mps, 4mps)
**.basicHosts[*].mobility.changeInterval = truncnormal(3s, 1s) # between turns
**.basicHosts[*].mobility.angleDelta = normal(-10deg, 10deg)#绕轴的旋转速度矢量

**.basicHosts[*].mobility.initialZ = 200m
**.basicHosts[*].mobility.constraintAreaMinZ = 100m
**.basicHosts[*].mobility.constraintAreaMaxZ = 300m

#X和Y轴按簇设置 其中簇头要设置起始位置 各簇头节点活动范围为125 而簇内节点活动范围为围绕簇头的100(可以用上某例子里的跟随模型!)
#**.hostRouters[0].mobility.initialX=700m
#**.hostRouters[0].mobility.initialY=1000m
##**.hostRouters[0].mobility.constraintAreaMinX = 575m
##**.hostRouters[0].mobility.constraintAreaMaxX = 825m
##**.hostRouters[0].mobility.constraintAreaMinY = 575m
##**.hostRouters[0].mobility.constraintAreaMaxY = 825m
#
#**.hostRouters[1].mobility.initialX=1500m
#**.hostRouters[1].mobility.initialY=500m
##**.hostRouters[1].mobility.constraintAreaMinX = 825m
##**.hostRouters[1].mobility.constraintAreaMaxX = 1075m
##**.hostRouters[1].mobility.constraintAreaMinY = 325m
##**.hostRouters[1].mobility.constraintAreaMaxY = 575m
#
#**.hostRouters[2].mobility.initialX=1500m
#**.hostRouters[2].mobility.initialY=1200m
##**.hostRouters[2].mobility.constraintAreaMinX = 825m
##**.hostRouters[2].mobility.constraintAreaMaxX = 1075m
##**.hostRouters[2].mobility.constraintAreaMinY = 825m
##**.hostRouters[2].mobility.constraintAreaMaxY = 1075m
#
#**.hostRouters[3].mobility.initialX=300m
#**.hostRouters[3].mobility.initialY=600m
##**.hostRouters[3].mobility.constraintAreaMinX = 700m
##**.hostRouters[3].mobility.constraintAreaMaxX = 1000m
##**.hostRouters[3].mobility.constraintAreaMinY = 200m
##**.hostRouters[3].mobility.constraintAreaMaxY = 500m
#
#**.hostRouters[4].mobility.initialX=1000m
#**.hostRouters[4].mobility.initialY=1000m
##**.hostRouters[4].mobility.constraintAreaMinX = 700m
##**.hostRouters[4].mobility.constraintAreaMaxX = 1000m
##**.hostRouters[4].mobility.constraintAreaMinY = 825m
##**.hostRouters[4].mobility.constraintAreaMaxY = 1075m

**.basicHosts[*].mobility.constraintAreaMinX = 200m
**.basicHosts[*].mobility.constraintAreaMaxX = 1300m
**.basicHosts[*].mobility.constraintAreaMinY = 200m
**.basicHosts[*].mobility.constraintAreaMaxY = 1300m

#new settings
**.basicHosts[0].mobility.getOthersPosition = true
**.basicHosts[0].mobility.basicNodeNum = 30		#注意和上方的num_hosts保持一致 	30
**.basicHosts[0].mobility.routerNodeNum = 0		#注意和簇头数量保持一致		5
**.basicHosts[0].mobility.getAllNodeStatusInterval = 0.01s	
**.basicHosts[0].mobility.networkName="UAVNetwork_OnlyBasicNode"
#new add 使节点随机从正常ping顺序以及簇头之间选择一个目的地址
**.basicHosts[*].app[*].allowPingCluster = true
#确认簇头后 每次该节点从正常ping顺序和簇头之间，选择簇头的机率
#min=1 很难选中簇头 max=99 非常容易选中簇头
#special= 100 不会选中簇头
**.basicHosts[*].app[*].choosePingClusterPercent = 99

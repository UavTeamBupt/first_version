[General]
network =myuav.UAVNetwork_Multi
image-path="images/device"
description = 30 UAVS communication continously
sim-time-limit = 60s	#仿真的持续时间


#【AODV专用设置】
*.configurator.addStaticRoutes = false#不默认设置路由
#*.host*.typename = "AodvRouter"
#初始化路由设置
**.arp.typename = "GlobalArp"
**.hostA[*].forwarding = false
**.hostB[*].forwarding = false
**.hostC[*].forwarding = false
**.hostA[*].multicastForwarding = false
**.hostB[*].multicastForwarding = false
**.hostC[*].multicastForwarding = false

**.hostRouters[*].forwarding = true
**.hostRouters[*].multicastForwarding = true

#【其他设置】
*.numHostsA = 3
*.numHostsB = 3
*.numHostsC = 3
debug-on-errors = true#在错误时候显示debug信息
*.configurator.config = xmldoc("multi_test.xml")#读取xml文件
#写入xml结果方便查看
*.configurator.dumpAddresses = true		#分配IP地址
*.configurator.dumpTopology = true		#打印网络拓扑结构
*.configurator.dumpLinks = true			#打印网络连接
*.configurator.dumpRoutes = true		#打印节点的路由表
*.configurator.dumpConfig = "multi_test_dump.xml"


#【其他奇怪的设置】
num-rngs = 3
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 1
#**.host*.**.channelNumber = 0

#【3D设置】
*.visualizer.osgVisualizer.typename = "IntegratedOsgVisualizer"
*.visualizer.osgVisualizer.sceneVisualizer.clearColor = "skyblue"
*.visualizer.osgVisualizer.sceneVisualizer.sceneImage = "showcases/desert"
*.visualizer.osgVisualizer.sceneVisualizer.sceneImageSize = 2000m	#5000m
*.visualizer.osgVisualizer.sceneVisualizer.axisLength = 500m		#1000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMinX = 0m			#-2000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMinY = 0m			#-2000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMinZ = 0m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMaxX = 2000m		#3000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMaxY = 2000m		#3000m
*.visualizer.osgVisualizer.sceneVisualizer.sceneMaxZ = 1000m		#3000m

#【可视化设置】
##干扰范围和通信范围
#**.radio.displayInterferenceRange = true
**.radio.displayCommunicationRange = true
*.visualizer.*.mediumVisualizer.displayCommunicationRanges = true	#通信范围可视化
#*.visualizer.*.mediumVisualizer.displayInterferenceRanges = true	#干扰范围可视化
#*.visualizer.*.mediumVisualizer.displaySignals = true	#传输显示为从主机发出的彩色环
#物理层
#*.visualizer.*.physicalLinkVisualizer.displayLinks = true
#数据链路层
*.visualizer.*.dataLinkVisualizer.displayLinks = true
*.visualizer.*.dataLinkVisualizer.packetFilter = "ping*"	#AODV*
*.visualizer.*.dataLinkVisualizer.nodeFilter = "*"		#hostRouter*

#网络层
*.visualizer.*.networkRouteVisualizer.displayRoutes = true
*.visualizer.*.networkRouteVisualizer.lineShift = 0
*.visualizer.*.networkRouteVisualizer.lineWidth = 10
*.visualizer.*.networkRouteVisualizer.packetFilter = "ping*"
#*.visualizer.*.networkRouteVisualizer.nodeFilter = "hostA*"		#hostRouter*
##可视化接口地址
#*.visualizer.*.interfaceTableVisualizer.displayInterfaceTables = true
##注意忽略Switch和AP接入点，因为他们没有IP地址
#*.visualizer.*.interfaceTableVisualizer.nodeFilter = "not (*switch* or *Switch* or *AP*)"
#显示移动速度和轨迹
#*.visualizer.*.mobilityVisualizer.displayVelocities = true
*.visualizer.*.mobilityVisualizer.displayMovementTrails = true
*.visualizer.*.mobilityVisualizer.animationSpeed = 1


#【无线电，mac层等设置】
*.host*.wlan[0].typename = "WirelessInterface"
#打开mac层的ack回复机制
*.host*.wlan[0].mac.typename = "CsmaCaMac"
*.host*.wlan[0].mac.ackTimeout = 300us	#300us

#最大队列长度
**.wlan[*].queue.typename = "DropTailQueue" #in routers
#簇头最大队列长度加大
*.hostRouters[*].wlan[0].mac.maxQueueSize = 20000
*.host*.wlan[0].mac.maxQueueSize = 10000				#10000

*.radioMedium.typename = "ApskScalarRadioMedium"		#ApskScalarRadioMedium
*.radioMedium.backgroundNoise.power = -90dBm			#背景的噪声模型 -90
*.radioMedium.mediumLimitCache.carrierFrequency = 2GHz	#载波频率

#TODO 需要根据host和Router的性质进行更改
*.host*.wlan[0].radio.typename = "ApskScalarRadio"	#ApskScalarRadio
*.host*.wlan[0].radio.carrierFrequency = 2GHz			#载波频率
**.ignorePartialInterference = true
#ATTENTION! 不同的带宽会导致loss rate急速增长 不要轻易更改!!
*.hostRouters[*].wlan[0].radio.bandwidth = 10MHz	#5M			
*.host*.wlan[0].radio.bandwidth = 10MHz				#2M
*.host*.wlan[0].radio.transmitter.preambleDuration = 10us	#10us
*.host*.wlan[0].radio.transmitter.headerLength = 8b
#信号强度过低就不会被接收到
*.host*.wlan[0].radio.receiver.sensitivity = -85dBm		
*.host*.wlan[0].radio.receiver.energyDetection = -85dBm	
*.host*.wlan[0].radio.receiver.snirThreshold = 4dB

#簇头的传输速率更大
#**.hostRouters[*].**.bitrate = 4Mbps#簇头的无线电数据传输速率
**.host*.**.bitrate = 1Mbps#无线电数据传输速率
**.hostRouters[*].wlan[*].radio.transmitter.power = 7mW	 	 #中间路由节点的通信范围设置   8
**.host*.wlan[*].radio.transmitter.power = 2mW	 	 	 		 #其他普通节点的范围设置 	 2

##或许是因为ApskScalarRadio没有这个干扰范围的问题 暂时不管
#*.host*.wlan[*].radio.**.interferenceRange = 500m


#【路径损耗模型 障碍物损耗】
#路径损耗
*.radioMedium.pathLoss.typename = ${pathlosstype="FreeSpacePathLoss","TwoRayInterference","RicianFading","LogNormalShadowing"}
#障碍物损耗
*.physicalEnvironment.coordinateSystemModule = "coordinateSystem"
*.*.mobility.coordinateSystemModule = "coordinateSystem" # reference TODO new add
#*.physicalEnvironment.spaceMinX = 100m
#*.physicalEnvironment.spaceMinY = 100m
#*.physicalEnvironment.spaceMinZ = 100m
#*.physicalEnvironment.spaceMaxX = 500m
#*.physicalEnvironment.spaceMaxY = 600m
#*.physicalEnvironment.spaceMaxZ = 700m
*.physicalEnvironment.config = xmldoc("obstacles.xml")
*.radioMedium.obstacleLoss.typename = "DielectricObstacleLoss"

#【ping设置】
#按簇进行更改 簇头和所有节点通信 簇内其他节点和本簇头通信
*.host*.numApps = 1
**.hostA[*].app[*].count = 1
**.hostA[*].app[*].continuous = true	#持续ping是不用改的。
**.hostB[*].app[*].count = 1
**.hostB[*].app[*].continuous = true	#持续ping是不用改的。
**.hostC[*].app[*].count = 1
**.hostC[*].app[*].continuous = true	#持续ping是不用改的。
**.hostRouters[*].app[*].count = 1
**.hostRouters[*].app[*].continuous = true	#持续ping是不用改的。
**.host*.app[*].typename = "PingApp"

#簇头节点 和其他簇头节点以及本簇内节点通信;其他节点和本簇内所有节点通信
**.hostRouters[0].app[*].destAddr="hostRouters[1] hostRouters[2]"
**.hostRouters[1].app[*].destAddr="hostRouters[0] hostRouters[2]"
**.hostRouters[2].app[*].destAddr="hostRouters[0] hostRouters[1]"
#另一种写法 似乎有错误
#**.hostRouters[*].app[*].destAddr="hostRouters[*]"
#4s,5s
**.hostRouters[*].app[*].startTime = uniform(10s,15s) 	# 簇头节点的第一次通信比较慢
#**.hostRouters[*].app[*].sendInterval = 3s				# 簇头的通信发送间隔比较大
**.hostRouters[*].app[*].printPing = true					# 这些printPing仅仅是在console里进行输出的 与visualizer无关!
#其他簇内节点0.1s 0.3s
**.hostA[*].app[*].destAddr = "hostRouters[0] hostA[1] hostA[2] "		#hostRouters[0]
**.hostA[*].app[*].startTime = uniform(5s,8s) 	# 簇内节点通信较快
#**.hostA[*].app[*].sendInterval = 0.5s			# 簇头的通信发送间隔比较大
**.hostA[*].app[*].printPing = true
#1s,2s
**.hostB[*].app[*].destAddr = "hostB[0] hostB[1] hostRouters[1]"	#hostRouters[1]
**.hostB[*].app[*].startTime = uniform(5s,8s) 	# 簇内节点通信较快
#**.hostB[*].app[*].sendInterval = 0.5s			# 簇头的通信发送间隔比较大
**.hostB[*].app[*].printPing = true
#1s,2s
**.hostC[*].app[*].destAddr = "hostC[0] hostC[2] hostRouters[2]"	#hostRouters[2]
**.hostC[*].app[*].startTime = uniform(5s,8s) 	# 簇内节点通信较快
#**.hostC[*].app[*].sendInterval = 0.5s			# 簇头的通信发送间隔比较大
**.hostC[*].app[*].printPing = true


#【移动性各种设置】
#TODO 簇头移动性不变 簇内各节点用mass+attached
**.host*.mobility.initFromDisplayString = false	#全部移动设备"**"的mobility
**.host*.mobility.typename = "MassMobility"#先设置Z轴

**.host*.osgModel = "3d/drone.ive.100.scale.0,0,90.rot"
**.host*.mobility.initialMovementHeading = uniform(0deg, 360deg)#初始化的UAV头朝向
**.host*.mobility.initialMovementElevation = uniform(-90deg, 90deg)#初始的UAV头俯仰角
**.host*.mobility.rotationAxisAngle = uniform(-10deg,10deg)
**.host*.mobility.faceForward = false

#簇头节点的移动性更大,变化频率更快,绕轴的变化范围大;而其他的节点移动性小,变化频率慢,绕轴的变化范围小
**.hostRouters[*].mobility.speed = truncnormal(50mps,8mps)
**.hostRouters[*].mobility.changeInterval = truncnormal(2s, 1s) # between turns
**.hostRouters[*].mobility.angleDelta = normal(-20deg, 20deg)#绕轴的旋转速度矢量

**.host*.mobility.speed = truncnormal(20mps, 4mps)
**.host*.mobility.changeInterval = truncnormal(3s, 1s) # between turns
**.host*.mobility.angleDelta = normal(-10deg, 10deg)#绕轴的旋转速度矢量

**.host*.mobility.initialZ = 200m
**.host*.mobility.constraintAreaMinZ = 100m
**.host*.mobility.constraintAreaMaxZ = 300m

#X和Y轴按簇设置 其中簇头要设置起始位置 各簇头节点活动范围为125 而簇内节点活动范围为围绕簇头的100(可以用上某例子里的跟随模型!)
**.hostRouters[0].mobility.initialX=700m
**.hostRouters[0].mobility.initialY=700m
**.hostRouters[0].mobility.constraintAreaMinX = 575m
**.hostRouters[0].mobility.constraintAreaMaxX = 825m
**.hostRouters[0].mobility.constraintAreaMinY = 575m
**.hostRouters[0].mobility.constraintAreaMaxY = 825m
**.hostA[*].mobility.constraintAreaMinX = 600m
**.hostA[*].mobility.constraintAreaMaxX = 800m
**.hostA[*].mobility.constraintAreaMinY = 600m
**.hostA[*].mobility.constraintAreaMaxY = 800m

**.hostRouters[1].mobility.initialX=950m
**.hostRouters[1].mobility.initialY=450m
**.hostRouters[1].mobility.constraintAreaMinX = 825m
**.hostRouters[1].mobility.constraintAreaMaxX = 1075m
**.hostRouters[1].mobility.constraintAreaMinY = 325m
**.hostRouters[1].mobility.constraintAreaMaxY = 575m
**.hostB[*].mobility.constraintAreaMinX = 850m
**.hostB[*].mobility.constraintAreaMaxX = 1050m
**.hostB[*].mobility.constraintAreaMinY = 350m
**.hostB[*].mobility.constraintAreaMaxY = 550m

**.hostRouters[2].mobility.initialX=950m
**.hostRouters[2].mobility.initialY=950m
**.hostRouters[2].mobility.constraintAreaMinX = 825m
**.hostRouters[2].mobility.constraintAreaMaxX = 1075m
**.hostRouters[2].mobility.constraintAreaMinY = 825m
**.hostRouters[2].mobility.constraintAreaMaxY = 1075m
**.hostC[*].mobility.constraintAreaMinX = 850m
**.hostC[*].mobility.constraintAreaMaxX = 1050m
**.hostC[*].mobility.constraintAreaMinY = 850m
**.hostC[*].mobility.constraintAreaMaxY = 1050m

